"""Report generation for AI Patch."""

import json
from datetime import datetime
from typing import Dict, Any


class ReportGenerator:
    """Generate reports in JSON and Markdown formats."""
    
    VERSION = "1.0.0"
    
    def create_report(
        self,
        target: str,
        provider: str,
        base_url: str,
        checks: Dict[str, Any],
        duration: float
    ) -> Dict[str, Any]:
        """Create a report dictionary."""
        
        # Determine overall status
        status = 'success'
        for check_name, check_result in checks.items():
            check_status = check_result.get('status', 'unknown')
            if check_status == 'fail':
                status = 'error'
                break
            elif check_status == 'warn' and status == 'success':
                status = 'warning'
        
        # Determine next step
        next_step = self._get_next_step(status, checks)
        
        return {
            'version': self.VERSION,
            'timestamp': datetime.utcnow().isoformat() + 'Z',
            'target': target,
            'provider': provider,
            'base_url': base_url,
            'checks': checks,
            'summary': {
                'status': status,
                'next_step': next_step,
                'duration_seconds': round(duration, 2)
            }
        }
    
    def generate_markdown(self, report: Dict[str, Any]) -> str:
        """Generate Markdown report from report data."""
        
        lines = []
        lines.append("# AI Patch Report")
        lines.append("")
        lines.append(f"**Generated:** {report['timestamp']}")
        lines.append(f"**Target:** {report['target']}")
        lines.append(f"**Provider:** {report['provider']}")
        lines.append(f"**Base URL:** {report['base_url']}")
        lines.append("")
        
        # Summary
        summary = report['summary']
        status_emoji = {
            'success': '✅',
            'warning': '⚠️',
            'error': '❌'
        }
        
        lines.append("## Summary")
        lines.append("")
        lines.append(f"**Status:** {status_emoji.get(summary['status'], '•')} {summary['status'].upper()}")
        lines.append(f"**Duration:** {summary['duration_seconds']}s")
        lines.append(f"**Next Step:** {summary['next_step']}")
        lines.append("")
        
        # Checks
        lines.append("## Checks")
        lines.append("")
        
        for check_name, check_result in report['checks'].items():
            status = check_result.get('status', 'unknown')
            status_icon = {
                'pass': '✅',
                'warn': '⚠️',
                'fail': '❌',
                'skipped': '⏭️'
            }
            
            lines.append(f"### {check_name.title()} {status_icon.get(status, '•')}")
            lines.append("")
            
            findings = check_result.get('findings', [])
            if findings:
                for finding in findings:
                    severity = finding.get('severity', 'info')
                    message = finding.get('message', '')
                    lines.append(f"- **{severity.upper()}**: {message}")
            else:
                lines.append("No issues found")
            
            lines.append("")
            
            metrics = check_result.get('metrics', {})
            if metrics:
                lines.append("**Metrics:**")
                for key, value in metrics.items():
                    lines.append(f"- {key}: {value}")
                lines.append("")
        
        # Add Badgr section if status is not success (warn or error)
        if summary['status'] != 'success':
            lines.append("## Optional: Per-Request Receipts")
            lines.append("")
            lines.append("If you need automatic receipts for every API call (latency, retries, cost tracking),")
            lines.append("[AI Badgr](https://aibadgr.com/signup) records this for real traffic.")
            lines.append("")
            lines.append("You can route requests through Badgr to keep receipts for real traffic.")
            lines.append("")
        
        # Footer
        lines.append("---")
        lines.append("")
        lines.append("Generated by AI Patch — re-run: `pipx run ai-patch` or `npx ai-patch`")
        
        return '\n'.join(lines)
    
    def _get_next_step(self, status: str, checks: Dict[str, Any]) -> str:
        """Determine the recommended next step."""
        
        if status == 'success':
            return "All checks passed. Consider running with --with-badgr for deep diagnosis."
        
        # Find first failure
        for check_name, check_result in checks.items():
            if check_result.get('status') in ['fail', 'warn']:
                findings = check_result.get('findings', [])
                if findings:
                    return f"Fix {check_name} issues, then run 'ai-patch apply --safe'"
        
        return "Review findings and run 'ai-patch apply --safe'"
