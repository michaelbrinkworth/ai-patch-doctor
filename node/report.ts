/**
 * Report generation for AI Patch
 */

interface CheckResult {
  status: 'pass' | 'warn' | 'fail' | 'skipped';
  findings: Array<{
    severity: 'info' | 'warning' | 'error';
    message: string;
    details?: any;
  }>;
  metrics?: Record<string, any>;
}

interface Checks {
  [key: string]: CheckResult;
}

export class ReportGenerator {
  private static readonly VERSION = '1.0.0';

  createReport(
    target: string,
    provider: string,
    baseUrl: string,
    checks: Checks,
    duration: number
  ): any {
    // Determine overall status
    let status = 'success';
    for (const checkName in checks) {
      const checkStatus = checks[checkName].status;
      if (checkStatus === 'fail') {
        status = 'error';
        break;
      } else if (checkStatus === 'warn' && status === 'success') {
        status = 'warning';
      }
    }

    // Determine next step
    const nextStep = this.getNextStep(status, checks);

    // Calculate estimated cost if cost check ran
    let estimatedCost = null;
    if (checks.cost) {
      const costMetrics = checks.cost.metrics || {};
      estimatedCost = costMetrics.estimated_cost_usd || null;
    }

    return {
      version: ReportGenerator.VERSION,
      timestamp: new Date().toISOString(),
      target,
      provider,
      base_url: baseUrl,
      checks,
      receipt_metadata: {
        receipt_format: 'badgr-compatible',
        execution_authority: 'ai-patch',
        billing_authority: 'customer'
      },
      summary: {
        status,
        next_step: nextStep,
        duration_seconds: Math.round(duration * 100) / 100,
        estimated_cost_usd: estimatedCost
      },
    };
  }

  generateMarkdown(report: any): string {
    const lines: string[] = [];

    lines.push('# AI Patch Report');
    lines.push('');
    lines.push(`**Generated:** ${report.timestamp}`);
    lines.push(`**Target:** ${report.target}`);
    lines.push(`**Provider:** ${report.provider}`);
    lines.push(`**Base URL:** ${report.base_url}`);
    lines.push('');

    // Summary
    const summary = report.summary;
    const statusEmoji: Record<string, string> = {
      success: '✅',
      warning: '⚠️',
      error: '❌',
    };

    lines.push('## Summary');
    lines.push('');
    lines.push(`**Status:** ${statusEmoji[summary.status] || '•'} ${summary.status.toUpperCase()}`);
    lines.push(`**Duration:** ${summary.duration_seconds}s`);
    lines.push(`**Next Step:** ${summary.next_step}`);
    lines.push('');

    // Checks
    lines.push('## Checks');
    lines.push('');

    for (const checkName in report.checks) {
      const checkResult = report.checks[checkName];
      const status = checkResult.status;
      const statusIcon: Record<string, string> = {
        pass: '✅',
        warn: '⚠️',
        fail: '❌',
        skipped: '⏭️',
      };

      lines.push(
        `### ${checkName.charAt(0).toUpperCase() + checkName.slice(1)} ${statusIcon[status] || '•'}`
      );
      lines.push('');

      const findings = checkResult.findings || [];
      if (findings.length > 0) {
        findings.forEach((finding: any) => {
          lines.push(`- **${finding.severity.toUpperCase()}**: ${finding.message}`);
        });
      } else {
        lines.push('No issues found');
      }

      lines.push('');

      const metrics = checkResult.metrics || {};
      if (Object.keys(metrics).length > 0) {
        lines.push('**Metrics:**');
        for (const key in metrics) {
          lines.push(`- ${key}: ${metrics[key]}`);
        }
        lines.push('');
      }
    }

    // Add Badgr section if status is not success (warn or error)
    if (summary.status !== 'success') {
      lines.push('## Optional: Per-Request Receipts');
      lines.push('');
      lines.push('If you need automatic receipts for every API call (latency, retries, cost tracking),');
      lines.push('[AI Badgr](https://aibadgr.com/signup) records this for real traffic.');
      lines.push('');
      lines.push('You can route requests through Badgr to keep receipts for real traffic.');
      lines.push('');
    }

    // Footer
    lines.push('---');
    lines.push('');
    lines.push('Generated by AI Patch — re-run: `pipx run ai-patch` or `npx ai-patch`');

    return lines.join('\n');
  }

  private getNextStep(status: string, checks: Checks): string {
    if (status === 'success') {
      return 'All checks passed. Consider running with --with-badgr for deep diagnosis.';
    }

    // Find first failure
    for (const checkName in checks) {
      if (checks[checkName].status === 'fail' || checks[checkName].status === 'warn') {
        const findings = checks[checkName].findings;
        if (findings && findings.length > 0) {
          return `Fix ${checkName} issues, then run 'ai-patch apply --safe'`;
        }
      }
    }

    return "Review findings and run 'ai-patch apply --safe'";
  }
}
