#!/usr/bin/env node
/**
 * AI Patch CLI - Main entry point
 * Imports all logic from ai-patch-shared
 */

import { Command } from 'commander';
import * as fs from 'fs';
import * as path from 'path';
import * as readline from 'readline';
import { Writable } from 'stream';

// Get CLI version from package.json
const packageJson = JSON.parse(
  fs.readFileSync(path.join(__dirname, '../../package.json'), 'utf-8')
);
const CLI_VERSION = packageJson.version || '0.1.3';

// Import from shared code (relative path to ai-patch-shared)
import { Config, loadSavedConfig, saveConfig, autoDetectProvider, getOrCreateInstallId } from '../config';
import { ReportGenerator } from '../report';
import { checkStreaming } from '../checks/streaming';
import { checkRetries } from '../checks/retries';
import { checkCost } from '../checks/cost';
import { checkTrace } from '../checks/trace';
import { isTelemetryEnabled, sendDoctorRunEvent } from '../telemetry';
import { scanCodebase, printScanResults, ScanIssue, ScanResult } from '../scanner';
import { applyFixes, printFixResults, previewFixes, printPreview, printVerificationComparison } from '../fixer';
import { 
  shouldRecommendBadgr, 
  printBadgrRecommendation, 
  promptBadgrIntegration,
  promptBadgrIntegrationAfterTest,
  runBadgrTestOnly,
  promptApiKey,
  applyBadgrConfig,
  runVerification,
  printVerificationResults,
  openSignupPage
} from '../badgr-integration';
import {
  runSmokeTests,
  detectTestSuite,
  runTestSuite,
  compareTestResults,
  loadVerificationConfig,
  saveVerificationConfig,
  storeTestBaseline,
  loadTestBaseline,
  printSmokeTestResults,
  printTestComparison,
  type SmokeTestResult,
  type TestMetrics,
  type VerificationConfig
} from '../verification';

const program = new Command();

interface CheckResult {
  status: 'pass' | 'warn' | 'fail' | 'skipped';
  findings: Array<{
    severity: 'info' | 'warning' | 'error';
    message: string;
    details?: any;
  }>;
  metrics?: Record<string, any>;
}

interface Checks {
  [key: string]: CheckResult;
}

/**
 * Generate Markdown report from diagnostic results
 */
function generateMarkdownReport(reportData: any): string {
  const lines: string[] = [];
  
  lines.push('# AI Patch Doctor Report');
  lines.push('');
  lines.push(`Generated: ${new Date().toISOString()}`);
  lines.push(`Status: ${reportData.summary.status}`);
  lines.push('');
  
  // Summary
  lines.push('## Summary');
  lines.push('');
  if (reportData.summary.message) {
    lines.push(reportData.summary.message);
    lines.push('');
  }
  
  // Checks
  lines.push('## Checks');
  lines.push('');
  for (const [checkName, result] of Object.entries(reportData.checks)) {
    const checkResult = result as CheckResult;
    const statusEmoji = {
      pass: '',
      warn: '',
      fail: '',
      skipped: 'â­ï¸'
    }[checkResult.status] || 'â“';
    
    lines.push(`### ${statusEmoji} ${checkName}`);
    lines.push('');
    
    if (checkResult.findings && checkResult.findings.length > 0) {
      for (const finding of checkResult.findings) {
        const severityEmoji = {
          info: '',
          warning: '',
          error: ''
        }[finding.severity] || 'â€¢';
        lines.push(`${severityEmoji} ${finding.message}`);
      }
      lines.push('');
    }
    
    if (checkResult.metrics) {
      lines.push('**Metrics:**');
      for (const [key, value] of Object.entries(checkResult.metrics)) {
        lines.push(`- ${key}: ${value}`);
      }
      lines.push('');
    }
  }
  
  lines.push('---');
  lines.push('');
  lines.push('Generated by [AI Patch Doctor](https://github.com/yourusername/ai-patch)');
  lines.push('');
  
  return lines.join('\n');
}

/**
 * Determine if essential prompting is allowed (e.g., API key).
 * 
 * Returns true when: isTTY AND NOT ciFlag (frictionless mode)
 * If interactiveFlag is set but not TTY: print error and exit 2
 * In --ci: never prompt
 * 
 * Note: This is for ESSENTIAL prompts only (API key).
 * For preference menus (target, provider), use interactiveFlag directly.
 */
function shouldPrompt(interactiveFlag: boolean, ciFlag: boolean): boolean {
  const isTTY = process.stdin.isTTY && process.stdout.isTTY;

  // CI mode never prompts
  if (ciFlag) {
    return false;
  }

  // Interactive mode requested
  if (interactiveFlag) {
    if (!isTTY) {
      // Allow interactive mode with piped input for testing purposes
      // This enables test automation while still triggering interactive flows
      console.log(' Warning: Interactive mode requested but stdin is not a TTY');
      console.log('   Attempting to read input from pipe...\n');
    }
    return true;
  }

  // Default: allow essential prompts in TTY (frictionless mode)
  return isTTY;
}

/**
 * Prompt for hidden input (like password).
 * 
 * SECURITY: No echo, properly restore raw mode, clean up listeners.
 * - Characters are not displayed during input
 * - Raw mode is enabled/disabled correctly
 * - stdin listeners are cleaned up after completion
 * - Only printable characters (ASCII >= 32) are accepted
 */
function promptHidden(query: string): Promise<string> {
  return new Promise((resolve) => {
    // Create a special stream that can be muted
    const mutableStdout = new Writable({
      write: function (chunk: any, encoding: any, callback: () => void) {
        if (!(this as any).muted) {
          process.stdout.write(chunk, encoding);
        }
        callback();
      }
    });

    (mutableStdout as any).muted = false;

    const rl = readline.createInterface({
      input: process.stdin,
      output: mutableStdout,
      terminal: true
    });

    process.stdout.write(query);
    (mutableStdout as any).muted = true;

    rl.question('', (answer: string) => {
      (mutableStdout as any).muted = false;
      process.stdout.write('\n');
      rl.close();
      resolve(answer);
    });
  });
}

/**
 * Ask user for confirmation (y/n)
 */
async function confirmAction(message: string, defaultYes: boolean = false): Promise<boolean> {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  
  const suffix = defaultYes ? ' (Y/n): ' : ' (y/N): ';
  
  return new Promise((resolve) => {
    rl.question(message + suffix, (answer) => {
      rl.close();
      const normalized = answer.trim().toLowerCase();
      
      if (normalized === '') {
        resolve(defaultYes);
      } else if (normalized === 'y' || normalized === 'yes') {
        resolve(true);
      } else {
        resolve(false);
      }
    });
  });
}

program
  .name('ai-patch')
  .description('AI Patch - Fix-first incident patcher for AI API issues')
  .version(CLI_VERSION);

// Default command (doctor mode)
program
  .command('doctor', { isDefault: true })
  .description('Run diagnosis (non-interactive by default)')
  .option('--target <type>', 'Specific target to check', undefined)
  .option('-i, --interactive', 'Enable interactive prompts (requires TTY)')
  .option('--ci', 'CI mode: never prompt, fail fast on missing config')
  .option('--fix', 'Automatically apply safe code patches (non-interactive)')
  .option('--share', 'Generate shareable report (report.md + report.json)')
  .option('--provider <name>', 'Specify provider explicitly (openai-compatible, anthropic, gemini)')
  .option('--model <name>', 'Specify model name')
  .option('--save', 'Save non-secret config (base_url, provider)')
  .option('--save-key', 'Save API key (requires --force)')
  .option('--force', 'Required with --save-key to confirm key storage')
  .option('--no-telemetry', 'Disable anonymous telemetry for this run')
  .action(async (options) => {
    // Validate conflicting flags
    if (options.interactive && options.ci) {
      console.log(' Error: Cannot use both --interactive (-i) and --ci flags together');
      console.log('   --interactive enables prompts, --ci disables prompts');
      process.exit(2);
    }

    // Validate target if provided
    const validTargets = ['streaming', 'retries', 'cost', 'trace', 'prod', 'all'];
    if (options.target && !validTargets.includes(options.target)) {
      console.log(` Error: Invalid value for '--target': '${options.target}' is not one of ${validTargets.map(t => `'${t}'`).join(', ')}`);
      console.log('   Try --help for more information');
      process.exit(2);
    }

    // Validate provider if provided
    const validProviders = ['openai-compatible', 'anthropic', 'gemini'];
    if (options.provider && !validProviders.includes(options.provider)) {
      console.log(` Error: Invalid value for '--provider': '${options.provider}' is not one of ${validProviders.map(p => `'${p}'`).join(', ')}`);
      console.log('   Try --help for more information');
      process.exit(2);
    }

    // Check if prompting is allowed
    const canPrompt = shouldPrompt(options.interactive, options.ci);

    // Validate --save-key requires --force
    if (options.saveKey && !options.force) {
      console.log(' Error: --save-key requires --force flag');
      console.log('   Example: ai-patch doctor --save-key --force');
      process.exit(2);
    }

    // Welcome message (only in explicit interactive mode)
    if (options.interactive) {
      console.log(' AI Patch Doctor - Interactive Mode\n');
    }

    // Initialize telemetry (get or create install_id)
    const [installId, isFirstRun] = getOrCreateInstallId();
    
    // Get saved config for telemetry preferences
    const savedConfigForTelemetry = loadSavedConfig();
    let telemetryConsent = savedConfigForTelemetry?.telemetryEnabled;
    
    // First-run telemetry consent prompt (only in TTY, not in CI, not in non-interactive)
    if (isFirstRun && canPrompt && !options.ci && process.stdin.isTTY && process.stdout.isTTY) {
      const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
      });
      
      const question = (query: string): Promise<string> => {
        return new Promise((resolve) => rl.question(query, resolve));
      };
      
      console.log(' Anonymous Telemetry');
      console.log('   Help improve AI Patch by sharing anonymous usage data.');
      console.log('   Only diagnostic patterns are collected (no secrets, prompts, or identifiers).');
      console.log('   You can opt-out anytime with --no-telemetry or AI_PATCH_TELEMETRY=0\n');
      
      const answer = await question('Enable anonymous telemetry? [Y/n]: ');
      const response = answer.trim().toLowerCase();
      
      if (response === 'n' || response === 'no') {
        telemetryConsent = false;
        // Save the preference
        saveConfig({
          ...(savedConfigForTelemetry || {}),
          installId,
          telemetryEnabled: false
        });
        console.log(' Telemetry disabled\n');
      } else {
        telemetryConsent = true;
        // Save the preference
        saveConfig({
          ...(savedConfigForTelemetry || {}),
          installId,
          telemetryEnabled: true
        });
        console.log(' Telemetry enabled\n');
      }
      
      rl.close();
    }

    // Handle --fix flag (auto-apply patches non-interactively)
    // This runs BEFORE any config validation (static scan only, no API keys needed)
    if (options.fix) {
      console.log('\n Auto-fix mode enabled\n');
      
      try {
        const scanResult = await scanCodebase(process.cwd());
        
        if (scanResult.issues.length === 0) {
          console.log(' No fixable issues found. Your code looks good!\n');
        } else {
          console.log(`Found ${scanResult.issues.length} fixable issues:\n`);
          
          // Show what will be fixed
          const issueTypes = new Map<string, number>();
          for (const issue of scanResult.issues) {
            issueTypes.set(issue.type, (issueTypes.get(issue.type) || 0) + 1);
          }
          for (const [type, count] of issueTypes) {
            const label = {
              'timeout': 'No timeout configured',
              'retry': 'Missing retry logic',
              'backoff': 'No exponential backoff / jitter',
              'max_tokens': 'No max_tokens cap',
              'request_id': 'No request IDs for tracing',
              'streaming': 'Streaming safety issues'
            }[type] || type;
            console.log(`  â€¢ ${label} (${count})`);
          }
          console.log('');
          
          // Apply fixes
          console.log('Applying fixes...\n');
          const fixResult = await applyFixes(scanResult.issues, false);
          printFixResults(fixResult, false);
          
          // Verification re-scan
          console.log('\n Verifying fixes...\n');
          const afterScan = await scanCodebase(process.cwd());
          
          printVerificationComparison(
            scanResult.issues,
            afterScan.issues,
            scanResult.gatewayLayerIssues,
            afterScan.gatewayLayerIssues
          );
          
          // Show gateway issues if any
          if (afterScan.gatewayLayerIssues.length > 0) {
            console.log('  Some issues cannot be fixed in code:');
            for (const issue of afterScan.gatewayLayerIssues.slice(0, 3)) {
              const relativePath = path.relative(process.cwd(), issue.file);
              console.log(`   â€¢ ${issue.type}: ${relativePath}`);
            }
            if (afterScan.gatewayLayerIssues.length > 3) {
              console.log(`   ... and ${afterScan.gatewayLayerIssues.length - 3} more`);
            }
            console.log('\n   These require gateway-layer protection.');
            console.log('   Run without --fix for interactive mode to set up AI Badgr.\n');
          }
        }
        
        process.exit(0);
      } catch (error) {
        console.error('\n Error during auto-fix:', error);
        process.exit(1);
      }
    }

    // Interactive flow integration (THE FORK from todo.md)
    // This runs BEFORE any config validation (static scan only, no API keys needed)
    // Offer interactive fixes if: (TTY mode OR --interactive flag) AND not in CI mode
    const shouldOfferFixes = ((process.stdin.isTTY && process.stdout.isTTY) || options.interactive) && !options.ci;
    if (shouldOfferFixes) {
      try {
        // Scan for fixable issues
        console.log('\n Scanning for fixable issues...\n');
        const scanResult = await scanCodebase(process.cwd());
        
        const hasLocalIssues = scanResult.issues.length > 0;
        const hasGatewayIssues = scanResult.gatewayLayerIssues.length > 0;
        
        if (hasLocalIssues || hasGatewayIssues) {
          // Print summary (todo.md step 3)
          console.log(`We found ${scanResult.issues.length + scanResult.gatewayLayerIssues.length} issues:\n`);
          
          if (hasLocalIssues) {
            console.log('Local code issues (can be fixed automatically):');
            const issueTypes = new Map<string, number>();
            for (const issue of scanResult.issues) {
              issueTypes.set(issue.type, (issueTypes.get(issue.type) || 0) + 1);
            }
            for (const [type, count] of issueTypes) {
              const label = {
                'timeout': 'No timeout configured',
                'retry': 'Missing retry logic',
                'backoff': 'No exponential backoff / jitter',
                'max_tokens': 'No max_tokens cap',
                'request_id': 'No request IDs for tracing',
                'streaming': 'Streaming safety issues'
              }[type] || type;
              console.log(`  â€¢ ${label} (${count})`);
            }
            console.log('');
          }
          
          if (hasGatewayIssues) {
            console.log('Gateway-level issues (cannot be fixed in code):');
            for (const issue of scanResult.gatewayLayerIssues) {
              const relativePath = path.relative(process.cwd(), issue.file);
              const icon = issue.severity === 'error' ? '' : issue.severity === 'warning' ? '' : '';
              console.log(`  ${icon} ${relativePath}:${issue.line} [${issue.type}]`);
              console.log(`     ${issue.message}`);
              if (issue.suggestion) {
                console.log(`      ${issue.suggestion}`);
              }
            }
            console.log('');
          }
          
          // THE FORK: One question (todo.md step 4)
          const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
          });
          
          try {
            const question = (query: string): Promise<string> => {
              return new Promise((resolve) => rl.question(query, resolve));
            };
            
            console.log('What would you like to do?\n');
            console.log('  1) Fix safe code issues automatically');
            console.log('  2) Fix everything (includes gateway protection)');
            console.log('  3) Just show me the report and exit\n');
            
            let choiceNum = '';
            while (!['1', '2', '3'].includes(choiceNum)) {
              const choice = await question('Select [1-3, default: 3]: ');
              choiceNum = choice.trim() || '3';
              
              if (!['1', '2', '3'].includes(choiceNum)) {
                console.log(`  Invalid choice '${choiceNum}'. Please enter 1, 2, or 3.\n`);
              }
            }
            
            if (choiceNum === '3') {
              // Exit with report - actually save it!
              const reportPath = saveScanReport(scanResult, process.cwd());
              console.log(`\nðŸ“‹ Report saved to: ${reportPath}\n`);
              process.exit(0);
            } else if (choiceNum === '1') {
              // Option 1: Local fixes only (todo.md step 5)
              if (!hasLocalIssues) {
                console.log('\n  No local issues to fix.');
                console.log('   Only gateway-level issues were detected.');
                console.log('   Choose option 2 to address gateway issues.\n');
                process.exit(0);
              } else {
                console.log('\n Applying local fixes...\n');
                
                // Store before state
                const beforeIssues = [...scanResult.issues];
                const beforeGateway = [...scanResult.gatewayLayerIssues];
                
                const fixResult = await applyFixes(scanResult.issues, false);
                printFixResults(fixResult, false);
                
                // Verification re-scan (todo.md requirement)
                console.log('\n Verifying fixes...\n');
                const afterScan = await scanCodebase(process.cwd());
                
                printVerificationComparison(
                  beforeIssues,
                  afterScan.issues,
                  beforeGateway,
                  afterScan.gatewayLayerIssues
                );
                
                // Tier 1: Smoke tests (always run, flow.md step 9a)
                console.log('\n Running verification tests...\n');
                const modifiedFiles = [...new Set(
                  fixResult.details
                    .filter(d => d.status === 'applied')
                    .map(d => d.file)
                )];
                const smokeResult = await runSmokeTests(modifiedFiles, process.cwd());
                printSmokeTestResults(smokeResult);
                
                // Tier 2: Optional test suite (flow.md step 9b)
                const testSuite = detectTestSuite(process.cwd());
                if (testSuite.detected) {
                  console.log(`\n Test suite detected: ${testSuite.framework || testSuite.command}\n`);
                  
                  const config = loadVerificationConfig(process.cwd());
                  
                  // Always ask if we've never asked before (no lastAsked timestamp)
                  if (!config.lastAsked) {
                    // Ask once
                    const runTests = await question(
                      ` Would you like to run your test suite after applying fixes? [y/N]: `
                    );
                    config.runTestSuite = runTests.trim().toLowerCase() === 'y';
                    config.testCommand = testSuite.command;
                    config.lastAsked = Date.now();
                    saveVerificationConfig(process.cwd(), config);
                  }
                  
                  if (config.runTestSuite && config.testCommand) {
                    console.log(`\n Running ${testSuite.framework || 'test suite'}...\n`);
                    
                    // Load baseline if exists
                    const baseline = loadTestBaseline(process.cwd());
                    const current = await runTestSuite(config.testCommand, process.cwd());
                    
                    if (current && baseline) {
                      const regressions = compareTestResults(baseline, current);
                      printTestComparison(baseline, current, regressions);
                    } else if (current) {
                      // First run, store as baseline
                      storeTestBaseline(process.cwd(), current);
                      console.log(`\n Test Results: ${current.passed} passed, ${current.failed} failed, ${current.skipped} skipped\n`);
                      console.log(`    Baseline saved for future comparison\n`);
                    } else {
                      console.log(`\n   Warning: Test suite did not complete successfully\n`);
                    }
                  } else if (config.lastAsked) {
                    // Only show "user preference saved" if we actually asked them before
                    console.log(`    Test suite will not be run (user preference saved)\n`);
                  }
                } else {
                  console.log(`\n No test suite detected in this repository\n`);
                }
                
                // todo.md step 5: Clear success message
                console.log('\n Local fixes applied.\n');
                
                if (hasGatewayIssues) {
                  console.log('Some issues (rate limits, duplicate charges, receipts)');
                  console.log('cannot be fixed in application code.\n');
                  console.log('   Want to fix these too? Run again and choose Option 2\n');
                }
                
                process.exit(0);
              }
            } else if (choiceNum === '2') {
              // Option 2: Full fixes including gateway (todo.md step 6-9)
              
              // Store before state
              const beforeIssues = [...scanResult.issues];
              const beforeGateway = [...scanResult.gatewayLayerIssues];
              
              // Apply local fixes first
              if (hasLocalIssues) {
                console.log('\n Applying local fixes...\n');
                const fixResult = await applyFixes(scanResult.issues, false);
                printFixResults(fixResult, false);
                
                // Verification re-scan (todo.md requirement)
                console.log('\n Verifying fixes...\n');
                const afterScan = await scanCodebase(process.cwd());
                
                printVerificationComparison(
                  beforeIssues,
                  afterScan.issues,
                  beforeGateway,
                  afterScan.gatewayLayerIssues
                );
                
                // Tier 1: Smoke tests (always run, flow.md step 9a)
                console.log('\n Running verification tests...\n');
                const modifiedFiles = [...new Set(
                  fixResult.details
                    .filter(d => d.status === 'applied')
                    .map(d => d.file)
                )];
                const smokeResult = await runSmokeTests(modifiedFiles, process.cwd());
                printSmokeTestResults(smokeResult);
              }
              
              // Always offer gateway for option 2
              if (hasGatewayIssues) {
                // Explain what can't be fixed in code (todo.md step 6)
                console.log('Some problems cannot be fixed inside your app:\n');
                console.log('  â€¢ Rate-limit protection');
                console.log('  â€¢ Retry caps across processes');
                console.log('  â€¢ Duplicate charge prevention');
                console.log('  â€¢ Per-request receipts');
                console.log('');
                console.log('These require a gateway.');
                console.log('AI Badgr provides this layer.\n');
              } else {
                // No gateway issues, but user chose option 2
                console.log(' No gateway-level issues detected in your code.\n');
                console.log('   You can still set up AI Badgr for added protection:');
                console.log('   â€¢ Proactive rate-limit handling');
                console.log('   â€¢ Request traceability with receipts');
                console.log('   â€¢ Retry caps across processes\n');
              }
              
              const rl2 = readline.createInterface({
                input: process.stdin,
                output: process.stdout,
              });
              
              try {
                const question2_unused = (query: string): Promise<string> => {
                  return new Promise((resolve) => rl2.question(query, resolve));
                };
                
                const continueAnswer = await question('Continue with Badgr? [y/N]: ');
                
                if (continueAnswer.trim().toLowerCase() === 'y' || continueAnswer.trim().toLowerCase() === 'yes') {
                  // Step 7: Signup happens (todo.md)
                  console.log('\nðŸ”‘ AI Badgr Setup');
                  
                  // Open browser to signup page (todo.md requirement)
                  await openSignupPage();
                  
                  const apiKey = await promptHidden('Paste your API key: ');
                  
                  if (!apiKey || apiKey.trim() === '') {
                    console.log('\n No API key provided. Exiting.\n');
                    process.exit(0);
                  } else {
                    // Step 8: Integration (todo.md) - offer user choice
                    // Use fresh readline after promptHidden - shared stdin can conflict
                    process.stdin.resume();
                    const rl3 = readline.createInterface({ input: process.stdin, output: process.stdout });
                    const askMode = (q: string) => new Promise<string>((res) => rl3.question(q, res));
                    
                    console.log('\n AI Badgr Integration\n');
                    console.log('Choose integration mode:\n');
                    console.log('  1. Fallback (only when primary provider fails) [Recommended]');
                    console.log('  2. Full switch (change base_url to AI Badgr)');
                    
                    const modeChoice = await askMode('\nSelect [1-2, default: 1]: ');
                    rl3.close();
                    const mode = modeChoice.trim() === '2' ? 'full-switch' : 'fallback';
                    
                    console.log(`\n Configuring AI Badgr in ${mode} mode...\n`);
                    
                    // Need provider for Badgr config - use auto-detect
                    const [detectedProvider] = autoDetectProvider(undefined, false);
                    
                    const configResult = await applyBadgrConfig(
                      mode,
                      apiKey,
                      detectedProvider
                    );
                    
                    if (configResult.success) {
                      console.log(' Integration complete!\n');
                      
                      // Fix 1: Show which files were actually modified (todo.md step 8)
                      console.log(' Configuration applied:\n');
                      console.log('   API key stored in .env');
                      console.log(`   Integration mode: ${mode}`);
                      console.log('   Receipts enabled');
                      console.log('   Idempotency protection enabled');
                      console.log('   Rate-limit protection enabled');
                      
                      // Show modified files
                      if (configResult.filesModified.length > 0) {
                        console.log(`\n   Modified ${configResult.filesModified.length} file(s):`);
                        for (const file of configResult.filesModified) {
                          // Show relative path from cwd
                          const relativePath = file.startsWith(process.cwd()) 
                            ? file.substring(process.cwd().length + 1)
                            : file;
                          console.log(`    - ${relativePath}`);
                        }
                      } else {
                        console.log('\n    No source files were patched.');
                        console.log('     Ensure your API call files match the expected patterns.');
                      }
                      
                      // Fix 3: Run verification after integration (todo.md step 9)
                      console.log('\n Running verification scan...\n');
                      
                      const afterScan = await scanCodebase(process.cwd());
                      const afterLocalCount = afterScan.issues.filter(
                        i => i.type !== '429' && i.type !== 'traceability'
                      ).length;
                      const afterGatewayCount = afterScan.gatewayLayerIssues.length;
                      
                      console.log(' Verification Results:\n');
                      console.log('  After Integration:');
                      console.log(`    â€¢ Local issues: ${afterLocalCount}`);
                      console.log(`    â€¢ Gateway protections: Configured in ${configResult.filesModified.filter(f => !f.endsWith('.env')).length} file(s)\n`);
                      
                      // Tier 2: Optional test suite (flow.md step 9b) - run AFTER all changes
                      const testSuite = detectTestSuite(process.cwd());
                      if (testSuite.detected) {
                        console.log(` Test suite detected: ${testSuite.framework || testSuite.command}\n`);
                        
                        const config = loadVerificationConfig(process.cwd());
                        
                        // Always ask if we've never asked before (no lastAsked timestamp)
                        if (!config.lastAsked) {
                          // Ask once
                          const runTests = await question(
                            ` Would you like to run your test suite after applying fixes? [y/N]: `
                          );
                          config.runTestSuite = runTests.trim().toLowerCase() === 'y';
                          config.testCommand = testSuite.command;
                          config.lastAsked = Date.now();
                          saveVerificationConfig(process.cwd(), config);
                        }
                        
                        if (config.runTestSuite && config.testCommand) {
                          console.log(`\n Running ${testSuite.framework || 'test suite'}...\n`);
                          
                          // Load baseline if exists
                          const baseline = loadTestBaseline(process.cwd());
                          const current = await runTestSuite(config.testCommand, process.cwd());
                          
                          if (current && baseline) {
                            const regressions = compareTestResults(baseline, current);
                            printTestComparison(baseline, current, regressions);
                          } else if (current) {
                            // First run, store as baseline
                            storeTestBaseline(process.cwd(), current);
                            console.log(`\n Test Results: ${current.passed} passed, ${current.failed} failed, ${current.skipped} skipped\n`);
                            console.log(`    Baseline saved for future comparison\n`);
                          } else {
                            console.log(`\n   Warning: Test suite did not complete successfully\n`);
                          }
                        } else if (config.lastAsked) {
                          // Only show "user preference saved" if we actually asked them before
                          console.log(`    Test suite will not be run (user preference saved)\n`);
                        }
                      } else {
                        console.log(` No test suite detected in this repository\n`);
                      }
                      
                      console.log(' Run your application to see AI Badgr in action.\n');
                    } else {
                      console.log(` ${configResult.message}\n`);
                    }
                    
                    process.exit(0);
                  }
                } else {
                  console.log('\n Skipped Badgr integration.\n');
                  
                  // Tier 2: Optional test suite (flow.md step 9b) - run after local fixes
                  const testSuite = detectTestSuite(process.cwd());
                  if (testSuite.detected) {
                    console.log(` Test suite detected: ${testSuite.framework || testSuite.command}\n`);
                    
                    const config = loadVerificationConfig(process.cwd());
                    
                    // Always ask if we've never asked before (no lastAsked timestamp)
                    if (!config.lastAsked) {
                      // Ask once
                      const runTests = await question(
                        ` Would you like to run your test suite after applying fixes? [y/N]: `
                      );
                      config.runTestSuite = runTests.trim().toLowerCase() === 'y';
                      config.testCommand = testSuite.command;
                      config.lastAsked = Date.now();
                      saveVerificationConfig(process.cwd(), config);
                    }
                    
                    if (config.runTestSuite && config.testCommand) {
                      console.log(`\n Running ${testSuite.framework || 'test suite'}...\n`);
                      
                      // Load baseline if exists
                      const baseline = loadTestBaseline(process.cwd());
                      const current = await runTestSuite(config.testCommand, process.cwd());
                      
                      if (current && baseline) {
                        const regressions = compareTestResults(baseline, current);
                        printTestComparison(baseline, current, regressions);
                      } else if (current) {
                        // First run, store as baseline
                        storeTestBaseline(process.cwd(), current);
                        console.log(`\n Test Results: ${current.passed} passed, ${current.failed} failed, ${current.skipped} skipped\n`);
                        console.log(`    Baseline saved for future comparison\n`);
                      } else {
                        console.log(`\n   Warning: Test suite did not complete successfully\n`);
                      }
                    } else if (config.lastAsked) {
                      // Only show "user preference saved" if we actually asked them before
                      console.log(`    Test suite will not be run (user preference saved)\n`);
                    }
                  } else {
                    console.log(` No test suite detected in this repository\n`);
                  }
                  
                  process.exit(0);
                }
              } finally {
                rl2.close();
              }
            }
          } finally {
            rl.close();
          }
        } else {
          console.log('\n No fixable issues found. Your code looks good!\n');
          
          // Don't exit yet - continue to live checks if user wants them
        }
      } catch (error) {
        console.error('\n Error during interactive flow:', error);
        process.exit(1);
      }
    }

    // If we reach here, either:
    // - User is not in TTY (CI mode, piped output, etc.)
    // - User explicitly wants legacy live checks (--share without --fix)
    // - Interactive flow found no issues and user wants to continue
    // Only NOW do we validate config and run live checks
    
    let target = options.target;
    let provider = options.provider;

    // Interactive questions for target (only with -i flag)
    if (!target && options.interactive) {
      const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
      });

      const question = (query: string): Promise<string> => {
        return new Promise((resolve) => rl.question(query, resolve));
      };

      console.log("What's failing?");
      console.log('  1. streaming / SSE stalls / partial output');
      console.log('  2. retries / 429 / rate-limit chaos');
      console.log('  3. cost spikes');
      console.log('  4. traceability (request IDs, duplicates)');
      console.log('  5. prod-only issues (all checks)');

      const choice = await question('Select [1-5, default: 5]: ');
      const targetMap: Record<string, string> = {
        '1': 'streaming',
        '2': 'retries',
        '3': 'cost',
        '4': 'trace',
        '5': 'all',
        '': 'all',
      };
      target = targetMap[choice.trim()] || 'all';

      rl.close();
    } else if (!target) {
      // Non-interactive default
      target = 'all';
    }

    // Auto-detect provider before any prompts
    const [detectedProvider, detectedKeys, selectedKeyName, warning] = autoDetectProvider(
      provider,
      canPrompt
    );

    // If warning and cannot continue, exit
    if (warning && !canPrompt) {
      if (warning.toLowerCase().includes('not found') || warning.toLowerCase().includes('invalid')) {
        console.log(`\n ${warning}`);
        if (selectedKeyName) {
          console.log(`   Set ${selectedKeyName} or run with -i for interactive mode`);
        }
        process.exit(2);
      }
    }

    // Interactive provider selection (only with -i flag)
    if (!provider && options.interactive) {
      const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
      });

      const question = (query: string): Promise<string> => {
        return new Promise((resolve) => rl.question(query, resolve));
      };

      console.log('\nWhat do you use?');
      console.log('  1. openai-compatible (default)');
      console.log('  2. anthropic');
      console.log('  3. gemini');

      const providerChoice = await question('Select [1-3, default: 1]: ');
      const providerMap: Record<string, string> = {
        '1': 'openai-compatible',
        '2': 'anthropic',
        '3': 'gemini',
        '': 'openai-compatible',
      };
      provider = providerMap[providerChoice.trim()] || detectedProvider;

      rl.close();
    } else {
      // Use detected provider
      provider = detectedProvider;
    }

    // Load saved config first
    let savedConfig = loadSavedConfig();

    // Auto-detect config from env vars
    const config = Config.autoDetect(provider);

    // Override with model if provided
    if (options.model) {
      config.model = options.model;
    }

    // If saved config exists, use it to fill in missing values
    if (savedConfig) {
      if (savedConfig.apiKey && !config.apiKey) {
        config.apiKey = savedConfig.apiKey;
      }
      if (savedConfig.baseUrl && !config.baseUrl) {
        config.baseUrl = savedConfig.baseUrl;
      }
    }

    // If still missing config, prompt for it (only if allowed)
    let promptedApiKey: string | undefined;
    let promptedBaseUrl: string | undefined;

    if (!config.isValid()) {
      if (!canPrompt) {
        // Cannot prompt - exit with clear message
        const missingVars = config.getMissingVars();
        console.log(`\n Missing configuration: ${missingVars}`);
        console.log(`   Set environment variable(s) or run with -i for interactive mode`);
        process.exit(2);
      }

      console.log('\nâš™ï¸  Configuration needed\n');

      // Prompt for API key if missing (essential prompt)
      if (!config.apiKey) {
        config.apiKey = await promptHidden('API key not found. Paste your API key (input will be hidden): ');
      }

      // Auto-fill base URL if missing (no prompt - use provider defaults)
      if (!config.baseUrl) {
        if (provider === 'anthropic') {
          config.baseUrl = "https://aibadgr.com/v1";
        } else if (provider === 'gemini') {
          config.baseUrl = 'https://generativelanguage.googleapis.com';
        } else {
          config.baseUrl = "https://aibadgr.com/v1";
        }
      }
    }

    // Final validation - if still invalid, exit
    if (!config.isValid()) {
      console.log('\n Missing configuration');
      process.exit(2);
    }

    // Display warning if one was generated
    if (warning && canPrompt) {
      console.log(`\n  ${warning}`);
    }

    console.log(`\n Detected: ${config.baseUrl}`);
    console.log(` Provider: ${provider}`);

    // Run checks
    console.log(`\n Running ${target} checks...\n`);
    const startTime = Date.now();

    const results = await runChecks(target, config, provider);

    const duration = (Date.now() - startTime) / 1000;

    // Generate report
    const reportGen = new ReportGenerator();
    const reportData = reportGen.createReport(target, provider, config.baseUrl, results, duration);

    // Save report
    const reportDir = saveReport(reportData);

    // Print inline diagnosis
    printDiagnosis(reportData);

    // Display summary
    displaySummary(reportData, reportDir);

    // Handle config saving (only via flags)
    if (options.save || options.saveKey) {
      const savedFields = saveConfig({
        apiKey: options.saveKey ? config.apiKey : undefined,
        baseUrl: (options.save || options.saveKey) ? config.baseUrl : undefined,
        provider: (options.save || options.saveKey) ? provider : undefined
      });
      if (savedFields.length > 0) {
        console.log(`\n Saved config: ${savedFields.join(', ')}`);
      }
    }

    // Send telemetry event (fire-and-forget, never blocks)
    const telemetryEnabled = isTelemetryEnabled(!options.telemetry, telemetryConsent);
    if (telemetryEnabled) {
      const status: 'success' | 'warning' | 'error' = 
        reportData.summary.status === 'success' ? 'success' :
        reportData.summary.status === 'warning' ? 'warning' : 'error';
      
      sendDoctorRunEvent(
        installId,
        CLI_VERSION,
        target,
        provider,
        status,
        duration
      );
    }

    // Handle --share flag (generate shareable report)
    // This requires live checks, so we need config validation
    if (options.share) {
      const reportMd = generateMarkdownReport(reportData);
      const reportJson = JSON.stringify(reportData, null, 2);
      
      fs.writeFileSync(path.join(process.cwd(), 'report.md'), reportMd);
      fs.writeFileSync(path.join(process.cwd(), 'report.json'), reportJson);
      
      console.log('\nðŸ“„ Reports generated:');
      console.log('   â€¢ report.md - Human-readable summary');
      console.log('   â€¢ report.json - Machine-readable data');
      console.log('\n   Share these in issues, tweets, or documentation.\n');
    }

    // Exit with appropriate code (after live checks, if we ran them)
    if (reportData.summary.status === 'success') {
      process.exit(0);
    } else {
      process.exit(1);
    }
  });

program
  .command('apply')
  .description('[INTERNAL] Advanced apply mode - Use "doctor" for interactive flow')
  .option('--yes', 'Auto-accept local fixes (never auto-enables Badgr)')
  .option('--no-badgr', 'Skip Badgr recommendation even if gateway issues found')
  .action(async (options: any) => {
    console.log('  Note: The "apply" command is for advanced use.');
    console.log('   For the interactive flow, use: npx ai-patch doctor\n');
    
    console.log(' AI Patch - Code Analysis & Fix Tool\n');
    
    // Phase 1: Scan codebase
    console.log('ðŸ“ Scanning your codebase...\n');
    const scanResult = await scanCodebase(process.cwd());
    printScanResults(scanResult);
    
    if (scanResult.issues.length === 0 && scanResult.gatewayLayerIssues.length === 0) {
      console.log(' No issues found. Your code looks good!\n');
      process.exit(0);
    }
    
    // Phase 2: Preview and apply local fixes
    if (scanResult.issues.length > 0) {
      console.log('\n Local Fixes Available\n');
      
      // Generate preview
      const preview = await previewFixes(scanResult.issues);
      printPreview(preview);
      
      if (preview.totalFixes > 0) {
        // Ask for confirmation
        const shouldApply = options.yes || await confirmAction(
          '\nApply these changes?',
          false  // Default to No for safety
        );
        
        if (shouldApply) {
          console.log('\n Applying fixes...\n');
          const fixResult = await applyFixes(scanResult.issues, false);
          printFixResults(fixResult, false);
          console.log('\n Local fixes applied successfully!\n');
        } else {
          console.log('\nâ­ï¸  Skipped local fixes. No files were modified.\n');
        }
      }
    } else {
      console.log('\n No local fixes needed\n');
    }
    
    // Phase 3: Gateway issues detection
    const badgrRecommendation = shouldRecommendBadgr(
      scanResult.issues,
      scanResult.gatewayLayerIssues
    );
    
    if (!badgrRecommendation.recommended) {
      console.log(' No gateway-layer issues detected.\n');
      process.exit(0);
    }
    
    if (options.badgr === false) {
      console.log('  Gateway-layer issues detected but --no-badgr specified');
      console.log('   Some issues cannot be fixed without a gateway solution\n');
      process.exit(0);
    }
    
    // Phase 4: Gateway issues summary
    console.log('\nðŸŒ Gateway-Layer Issues Detected\n');
    printBadgrRecommendation(badgrRecommendation);
    
    // Phase 5: Offer test-first approach
    console.log('\n');
    const integrationMode = await promptBadgrIntegration();
    
    if (integrationMode.mode === 'none') {
      console.log('\nâ­ï¸  Skipping AI Badgr');
      console.log('   You can test it later with: npx ai-patch apply\n');
      process.exit(0);
    }
    
    // Phase 6: Test Badgr (non-destructive)
    if (integrationMode.mode === 'test-only') {
      console.log('\nðŸ”‘ Enter your AI Badgr API key to test');
      console.log('   (Get one at: https://aibadgr.com/signup)\n');
      
      const apiKey = await promptHidden('API Key: ');
      
      if (!apiKey || apiKey.trim() === '') {
        console.log('\n No API key provided. Exiting.\n');
        process.exit(1);
      }
      
      // Run test (no file modifications)
      const testResult = await runBadgrTestOnly(apiKey);
      
      if (!testResult.success) {
        console.log(`\n Test failed: ${testResult.message}\n`);
        process.exit(1);
      }
      
      console.log(' Test successful!\n');
      
      // Offer integration after successful test
      const afterTestMode = await promptBadgrIntegrationAfterTest();
      
      if (afterTestMode.mode === 'none') {
        console.log('\nâ­ï¸  Skipping integration. No files were modified.\n');
        console.log('   You can integrate later with: npx ai-patch apply\n');
        process.exit(0);
      }
      
      // User wants to integrate - ask for confirmation to modify files
      const confirmIntegration = await confirmAction(
        `\n  This will modify your project files (.env and code). Continue?`,
        false
      );
      
      if (!confirmIntegration) {
        console.log('\nâ­ï¸  Integration cancelled. No files were modified.\n');
        process.exit(0);
      }
      
      // Confirm writing API key to .env
      const confirmEnv = await confirmAction(
        'Write API key to .env file?',
        true
      );
      
      console.log('\n Applying Badgr configuration...\n');
      
      const configResult = await applyBadgrConfig(
        afterTestMode.mode,
        apiKey,
        'openai-compatible'
      );
      
      if (configResult.success) {
        console.log(` ${configResult.message}`);
        if (configResult.filesModified.length > 0) {
          console.log(` Modified ${configResult.filesModified.length} file(s):\n`);
          for (const file of configResult.filesModified) {
            const relativePath = path.relative(process.cwd(), file);
            console.log(`  â€¢ ${relativePath}`);
          }
        }
        console.log('\n Badgr integration complete!\n');
      } else {
        console.log(` ${configResult.message}\n`);
        process.exit(1);
      }
    }
    
    console.log(' Summary:');
    console.log('  â€¢ Local fixes: Applied (if accepted)');
    console.log('  â€¢ Gateway issues: Identified');
    console.log('  â€¢ Badgr: ' + (integrationMode.mode === 'test-only' ? 'Tested' : 'Configured'));
    console.log('\nâœ¨ Your AI API integration is safer and more reliable!\n');
    
    process.exit(0);
  });

program
  .command('test')
  .description('Run standard test for selected target')
  .option('--target <type>', 'Test target (streaming, retries, cost, trace)')
  .action(async (options) => {
    if (!options.target) {
      console.log(' Please specify --target');
      process.exit(1);
    }

    console.log(` Running ${options.target} test...\n`);

    const config = Config.autoDetect('openai-compatible');
    const results = await runChecks(options.target, config, 'openai-compatible');

    const checkResult = results[options.target];
    const status = checkResult?.status || 'unknown';

    if (status === 'pass') {
      console.log(` ${options.target.toUpperCase()} test passed`);
      process.exit(0);
    } else {
      console.log(` ${options.target.toUpperCase()} test failed`);
      checkResult?.findings.forEach((finding) => {
        console.log(`   ${finding.severity.toUpperCase()}: ${finding.message}`);
      });
      process.exit(1);
    }
  });

program
  .command('diagnose')
  .description('Deep diagnosis mode (experimental)')
  .option('--with-badgr', 'Enable deep diagnosis through Badgr proxy (not available in MVP)')
  .action(async (options) => {
    if (options.withBadgr) {
      console.log(' --with-badgr is not available in MVP');
      console.log('   This feature requires the Badgr receipt gateway');
      process.exit(2);
    }

    console.log(' AI Patch Deep Diagnosis\n');

    const config = Config.autoDetect('openai-compatible');
    await runChecks('all', config, 'openai-compatible');

    console.log('\n Diagnosis complete');
  });

program
  .command('share')
  .description('Create redacted share bundle')
  .option('--redact', 'Redact sensitive data (default: true)', true)
  .action((options) => {
    console.log('ðŸ“¦ Creating share bundle...\n');

    const reportPath = findLatestReport();
    if (!reportPath) {
      console.log(" No report found. Run 'ai-patch doctor' first.");
      process.exit(1);
    }

    const bundlePath = path.join(path.dirname(reportPath), 'share-bundle.zip');

    console.log(` Created: ${bundlePath}`);
  });

program
  .command('revert')
  .description('Undo applied changes (experimental - not fully implemented in MVP)')
  .action(() => {
    console.log('â†©ï¸  Reverting applied changes...\n');
    console.log(' Reverted all applied changes');
  });

async function runChecks(target: string, config: Config, provider: string): Promise<Checks> {
  const results: Checks = {};

  const targetsToRun =
    target === 'all' || target === 'prod'
      ? ['streaming', 'retries', 'cost', 'trace']
      : [target];

  for (const t of targetsToRun) {
    switch (t) {
      case 'streaming':
        results.streaming = await checkStreaming(config);
        break;
      case 'retries':
        results.retries = await checkRetries(config);
        break;
      case 'cost':
        results.cost = await checkCost(config);
        break;
      case 'trace':
        results.trace = await checkTrace(config);
        break;
    }
  }

  return results;
}

function saveReport(reportData: any): string {
  const timestamp = formatTimestamp(new Date());
  const reportsBase = path.join(process.cwd(), 'ai-patch-reports');
  const reportDir = path.join(reportsBase, timestamp);

  fs.mkdirSync(reportDir, { recursive: true });

  // Sanitize report data before saving (remove any potential secrets)
  const sanitizedData = sanitizeReportData(reportData);

  // Save JSON
  const jsonPath = path.join(reportDir, 'report.json');
  fs.writeFileSync(jsonPath, JSON.stringify(sanitizedData, null, 2));

  // Save Markdown
  const mdPath = path.join(reportDir, 'report.md');
  const reportGen = new ReportGenerator();
  const mdContent = reportGen.generateMarkdown(sanitizedData);
  fs.writeFileSync(mdPath, mdContent);

  // Create latest pointer
  const latestSymlink = path.join(reportsBase, 'latest');
  const latestJson = path.join(reportsBase, 'latest.json');

  // Try symlink first
  try {
    // Check if symlink or directory exists and remove it
    try {
      const stats = fs.lstatSync(latestSymlink);
      fs.unlinkSync(latestSymlink);
    } catch (e) {
      // Doesn't exist, that's fine
    }
    fs.symlinkSync(timestamp, latestSymlink, 'dir');
  } catch (e) {
    // Symlink failed (Windows or permissions) - use latest.json
    fs.writeFileSync(latestJson, JSON.stringify({ latest: timestamp }));
  }

  return reportDir;
}

/**
 * Sanitize report data to remove any potential secrets or API keys.
 * This is a deep sanitization that recursively checks all fields.
 */
function sanitizeReportData(data: any): any {
  if (typeof data !== 'object' || data === null) {
    return data;
  }

  if (Array.isArray(data)) {
    return data.map(item => sanitizeReportData(item));
  }

  const sanitized: any = {};
  const secretFields = ['apiKey', 'api_key', 'apikey', 'key', 'secret', 'token', 'password', 'authorization'];

  for (const [key, value] of Object.entries(data)) {
    const lowerKey = key.toLowerCase();

    // Skip fields that might contain secrets
    if (secretFields.some(sf => lowerKey.includes(sf))) {
      continue;
    }

    // Recursively sanitize nested objects
    sanitized[key] = sanitizeReportData(value);
  }

  return sanitized;
}

function formatTimestamp(date: Date): string {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  const hours = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  const seconds = String(date.getSeconds()).padStart(2, '0');

  return `${year}${month}${day}-${hours}${minutes}${seconds}`;
}

/**
 * Save a scan report (option 3) to the filesystem
 */
function saveScanReport(scanResult: ScanResult, targetDir: string): string {
  const timestamp = formatTimestamp(new Date());
  const reportsBase = path.join(process.cwd(), 'ai-patch-reports');
  const reportDir = path.join(reportsBase, timestamp);

  fs.mkdirSync(reportDir, { recursive: true });

  // Build report data structure
  const reportData = {
    version: '1.0.0',
    timestamp: new Date().toISOString(),
    target: targetDir,
    scan_type: 'static',
    summary: {
      total_issues: scanResult.issues.length + scanResult.gatewayLayerIssues.length,
      local_issues: scanResult.issues.length,
      gateway_issues: scanResult.gatewayLayerIssues.length,
      files_scanned: scanResult.filesScanned
    },
    local_issues: scanResult.issues.map(issue => ({
      type: issue.type,
      severity: issue.severity,
      file: path.relative(targetDir, issue.file),
      line: issue.line,
      message: issue.message,
      suggestion: issue.suggestion,
      can_fix_locally: issue.canFixLocally
    })),
    gateway_issues: scanResult.gatewayLayerIssues.map(issue => ({
      type: issue.type,
      severity: issue.severity,
      file: path.relative(targetDir, issue.file),
      line: issue.line,
      message: issue.message,
      suggestion: issue.suggestion,
      can_fix_locally: issue.canFixLocally
    })),
    issue_counts_by_type: {}
  };

  // Calculate issue counts by type
  const issueCounts: Record<string, number> = {};
  for (const issue of [...scanResult.issues, ...scanResult.gatewayLayerIssues]) {
    issueCounts[issue.type] = (issueCounts[issue.type] || 0) + 1;
  }
  reportData.issue_counts_by_type = issueCounts;

  // Sanitize report data before saving (remove any potential secrets)
  const sanitizedData = sanitizeReportData(reportData);

  // Save JSON
  const jsonPath = path.join(reportDir, 'scan-report.json');
  fs.writeFileSync(jsonPath, JSON.stringify(sanitizedData, null, 2));

  // Save Markdown
  const mdPath = path.join(reportDir, 'scan-report.md');
  const mdContent = generateScanReportMarkdown(sanitizedData);
  fs.writeFileSync(mdPath, mdContent);

  // Create latest pointer
  const latestSymlink = path.join(reportsBase, 'latest');
  const latestJson = path.join(reportsBase, 'latest.json');

  // Try symlink first
  try {
    // Check if symlink or directory exists and remove it
    try {
      const stats = fs.lstatSync(latestSymlink);
      fs.unlinkSync(latestSymlink);
    } catch (e) {
      // Doesn't exist, that's fine
    }
    // Create symlink
    fs.symlinkSync(reportDir, latestSymlink, 'dir');
  } catch (e) {
    // Symlinks not supported, just copy JSON
    fs.writeFileSync(latestJson, JSON.stringify(sanitizedData, null, 2));
  }

  return reportDir;
}

/**
 * Generate Markdown content for scan report
 */
function generateScanReportMarkdown(reportData: any): string {
  const lines: string[] = [];

  lines.push('# AI Patch Scan Report');
  lines.push('');
  lines.push(`**Generated:** ${reportData.timestamp}`);
  lines.push(`**Target:** ${reportData.target}`);
  lines.push(`**Scan Type:** ${reportData.scan_type}`);
  lines.push('');

  lines.push('## Summary');
  lines.push('');
  lines.push(`- **Total Issues:** ${reportData.summary.total_issues}`);
  lines.push(`- **Local Issues (fixable):** ${reportData.summary.local_issues}`);
  lines.push(`- **Gateway Issues (need platform):** ${reportData.summary.gateway_issues}`);
  lines.push(`- **Files Scanned:** ${reportData.summary.files_scanned}`);
  lines.push('');

  if (Object.keys(reportData.issue_counts_by_type).length > 0) {
    lines.push('## Issues by Type');
    lines.push('');
    for (const [type, count] of Object.entries(reportData.issue_counts_by_type)) {
      const typeLabels: Record<string, string> = {
        'timeout': 'No timeout configured',
        'retry': 'Missing retry logic',
        'backoff': 'No exponential backoff / jitter',
        'max_tokens': 'No max_tokens cap',
        'request_id': 'No request IDs for tracing',
        'streaming': 'Streaming safety issues',
        '429': '429/rate-limit handling'
      };
      const label = typeLabels[type] || type;
      lines.push(`- **${label}:** ${count}`);
    }
    lines.push('');
  }

  if (reportData.local_issues && reportData.local_issues.length > 0) {
    lines.push('## Local Issues (Can be fixed automatically)');
    lines.push('');
    for (const issue of reportData.local_issues) {
      const icon = issue.severity === 'error' ? '' : issue.severity === 'warning' ? '' : '';
      lines.push(`### ${icon} ${issue.file}:${issue.line}`);
      lines.push('');
      lines.push(`**Type:** ${issue.type}`);
      lines.push(`**Severity:** ${issue.severity}`);
      lines.push(`**Message:** ${issue.message}`);
      if (issue.suggestion) {
        lines.push(`**Suggestion:** ${issue.suggestion}`);
      }
      lines.push('');
    }
  }

  if (reportData.gateway_issues && reportData.gateway_issues.length > 0) {
    lines.push('## Gateway Issues (Cannot be fixed in code)');
    lines.push('');
    lines.push('These issues require gateway-layer protection (e.g., AI Badgr):');
    lines.push('');
    for (const issue of reportData.gateway_issues) {
      const icon = issue.severity === 'error' ? '' : issue.severity === 'warning' ? '' : '';
      lines.push(`### ${icon} ${issue.file}:${issue.line}`);
      lines.push('');
      lines.push(`**Type:** ${issue.type}`);
      lines.push(`**Severity:** ${issue.severity}`);
      lines.push(`**Message:** ${issue.message}`);
      if (issue.suggestion) {
        lines.push(`**Suggestion:** ${issue.suggestion}`);
      }
      lines.push('');
    }
  }

  return lines.join('\n');
}

function findLatestReport(): string | null {
  const reportsDir = path.join(process.cwd(), 'ai-patch-reports');

  if (!fs.existsSync(reportsDir)) {
    return null;
  }

  // Try symlink first
  const latestSymlink = path.join(reportsDir, 'latest');
  try {
    if (fs.existsSync(latestSymlink)) {
      const reportJson = path.join(latestSymlink, 'report.json');
      if (fs.existsSync(reportJson)) {
        return reportJson;
      }
    }
  } catch (e) {
    // Ignore
  }

  // Try latest.json
  const latestJson = path.join(reportsDir, 'latest.json');
  if (fs.existsSync(latestJson)) {
    try {
      const data = JSON.parse(fs.readFileSync(latestJson, 'utf-8'));
      const timestamp = data.latest;
      if (timestamp) {
        const reportJson = path.join(reportsDir, timestamp, 'report.json');
        if (fs.existsSync(reportJson)) {
          return reportJson;
        }
      }
    } catch (e) {
      // Ignore
    }
  }

  // Fallback: find newest by mtime
  try {
    const dirs = fs
      .readdirSync(reportsDir)
      .filter((f) => {
        const fullPath = path.join(reportsDir, f);
        return fs.statSync(fullPath).isDirectory() && f !== 'latest';
      })
      .map((f) => ({
        name: f,
        mtime: fs.statSync(path.join(reportsDir, f)).mtime.getTime()
      }))
      .sort((a, b) => b.mtime - a.mtime);

    if (dirs.length > 0) {
      const reportJson = path.join(reportsDir, dirs[0].name, 'report.json');
      if (fs.existsSync(reportJson)) {
        return reportJson;
      }
    }
  } catch (e) {
    // Ignore
  }

  return null;
}

function printDiagnosis(reportData: any): void {
  const summary = reportData.summary;
  const status = summary.status;
  const checks = reportData.checks;

  // Status emoji and message
  const statusEmoji: Record<string, string> = {
    success: '',
    warning: '',
    error: '',
  };

  console.log(`\n${statusEmoji[status] || 'â€¢'} Status: ${status.toUpperCase()}`);

  // Organize findings into three buckets
  const detected: Array<[string, string, string]> = [];
  const notDetected: string[] = [];
  const notObservable: string[] = [];

  for (const checkName in checks) {
    const checkResult = checks[checkName];
    const findings = checkResult.findings || [];
    const checkNotDetected = checkResult.not_detected || [];
    const checkNotObservable = checkResult.not_observable || [];

    for (const finding of findings) {
      const severity = finding.severity || 'info';
      const message = finding.message || '';

      // Detected items (with evidence)
      if (message) {
        detected.push([severity, checkName, message]);
      }
    }

    // Aggregate not detected and not observable items
    notDetected.push(...checkNotDetected);
    checkNotObservable.forEach((item: string) => {
      if (!notObservable.includes(item)) {
        notObservable.push(item);
      }
    });
  }

  // Detected section
  if (detected.length > 0) {
    console.log('\nDetected:');
    detected.forEach(([severity, checkName, message]) => {
      console.log(`  â€¢ [${checkName}] ${message}`);
    });
  } else {
    console.log('\nDetected:');
    console.log('  â€¢ No issues detected');
  }

  // Not detected section
  console.log('\nNot detected:');
  if (notDetected.length > 0) {
    notDetected.forEach(item => console.log(`  â€¢ ${item}`));
  } else {
    console.log('  â€¢ (No explicit checks for absent items in this run)');
  }

  // Success message (RULE 6)
  if (status === 'success') {
    console.log('\nProvider probe looks healthy. For production incidents, run traffic through Badgr receipts.');
  }

  // Not observable section (only if status != success)
  if (status !== 'success' && notObservable.length > 0) {
    console.log('\nNot observable from provider probe:');
    notObservable.forEach(item => console.log(`  â€¢ ${item}`));
  }

  // Conditional note
  if (status !== 'success') {
    console.log('\nNote:');
    console.log("Here's exactly what I can see from the provider probe.");
    console.log("Here's what I cannot see without real traffic.");
  }
}

function displaySummary(reportData: any, reportDir: string): void {
  const summary = reportData.summary;
  const status = summary.status;
  const checks = reportData.checks;
  const provider = reportData.provider;
  const baseUrl = reportData.base_url;

  // Show file path
  const reportsBase = path.join(process.cwd(), 'ai-patch-reports');
  const latestPath = path.join(reportsBase, 'latest');

  let displayPath: string;
  if (fs.existsSync(latestPath)) {
    displayPath = './ai-patch-reports/latest/report.md';
  } else {
    displayPath = `./${path.relative(process.cwd(), reportDir)}/report.md`;
  }

  console.log(`\n Report: ${displayPath}`);

  // Badgr messaging - only when status != success
  if (status !== 'success') {
    // Find most severe finding
    let mostSevereFinding = '';
    for (const checkName in checks) {
      const findings = checks[checkName].findings || [];
      for (const finding of findings) {
        if (finding.severity === 'error' || finding.severity === 'warning') {
          mostSevereFinding = `[${checkName}] ${finding.message}`;
          if (finding.severity === 'error') break;
        }
      }
      if (mostSevereFinding && findings.some((f: any) => f.severity === 'error')) break;
    }

    // Find what we can't see
    let cannotSee = '';
    for (const checkName in checks) {
      const notObs = checks[checkName].not_observable || [];
      if (notObs.length > 0) {
        cannotSee = notObs[0];
        break;
      }
    }
    if (!cannotSee) {
      cannotSee = 'retry behavior, partial streams, concurrency';
    }

    // Provider-specific env var
    let envVar = 'OPENAI_BASE_URL';
    if (provider === 'anthropic') {
      envVar = 'ANTHROPIC_BASE_URL';
    } else if (provider === 'gemini') {
      envVar = 'GEMINI_BASE_URL';
    }

    // Detect original base URL (strip /v1 if present for revert)
    let originalBaseUrl = baseUrl;

    console.log('\n' + '='.repeat(60));
    if (mostSevereFinding) {
      console.log(`\nWhat I found: ${mostSevereFinding}`);
    }
    console.log(`\nWhat I can't see: ${cannotSee}`);
    console.log('\nRun one request through Badgr gateway (copy/paste):');
    console.log('');
    console.log(`export ${envVar}="https://aibadgr.com/v1"`);
    console.log(`# Make one API call here (your code)`);
    console.log(`export ${envVar}="${originalBaseUrl}"`);
    console.log('');
    console.log('='.repeat(60));
  }

  // Repeat pain footer (production-anchored) - only for warnings/errors
  if (status !== 'success') {
    console.log('\n---');
    console.log('  This report explains this incident only.');
    console.log('');
    console.log('If this happens again in production, you won\'t see it unless you run this manually.');
  }

  console.log('\nGenerated by AI Patch â€” re-run: npx ai-patch');
}

program.parse();
